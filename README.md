<p>Processing and Evaluating the INSAT 3D Remote SensingObservations: Weather and Climate ApplicationsManinder Singh (MS23074)3/08/2024AcknowledgementThis Project is made possible due to Prof. Raju Attada. I am very grateful to Prof. Raju Attada forproviding me the opportunity to work under them. I am specially thankful for the freedom and timeto explore the Remote sensing world. This experience has been invaluable and will undoubtedlybenefit me in my future endeavors.1IntroductionRemote Sensing is the process of acquiring information about an object or a region from a distancetypically through a satellite. It involves collecting, processing and evaluating the information gainedthrough detection and measurement of various physical properties by interpreting the reflection andemission of waves from the region of interest. Remote sensing is crucial for monitoring atmosphericconditions, predicting weather patterns, and studying climate changes. Satellites equipped with ad-vanced sensors capture data on various atmospheric parameters, which can be processed and analyzedto understand and predict atmospheric phenomenons. This project uses the Sounder data derivedfrom INSAT-3D and INSAT-3DR for the whole duration of this document. This project’s one of theinterest point is that, all the code that has been used in here is in Python language which is famousfor its simplicity and easy of understanding which makes this project enable for further additions andoptimisations.2MOSDAC (Getting Data)MOSDAC - Meteorological and Oceanographic Satellite Data Archival Centre www.mosdac.gov.in, isa data portal that provides earth observation data from Indian satellites in our case INSAT-3D andINSAT-3DR. MOSDAC provides a catalog of Satellite data to choose between. And to access thisdata, the user first have to register at mosdac. After registration, mosdac provides a catalog of dataprovided by the satellites and radar. Choosing the data-file products depend in the region of interestand level of processing. The products are divided in Sector A and B. Sector A maps over Indianlandmass and Sector B covers the Indian Ocean. See 1. The Sector A is then divided into two PartsA1 and A2. Majoritly the Sector B is for Oceanography purpose and for Ocean studies. Level ofprocessing is divided in various segments L1B, L2B, L1C and some others. L1B is radiometricallycorrected data, L2B consists of Geo-physical Parameters that are derived from L1B and L1C is geo-refrenced product. All the products mentioned above are packaged in hdf5 format which is essentiallyused to store complex and vast amount of data for processing. After selection and conformation ofthe product type as per the user requirement, the product becomes available to downloaded either viawebsite interface or by sftp protocol. It is recommended to use sftp protocol if the download is in bulk.After saving the files we can work on them.Our Focus would be on the archived SOUNDER data from the INSAT-3D and INSAT-3DR satellitesOn Sector A1 with processing level of L1B and L2B, starting from 01-JUN-2019 till 31-AUG-2019.1Figure 1: Scan Area of INSAT-3D sounder. Taken from [SPB18].3INSAT-3DINSAT-3D is an advanced weather satellite launched by the Indian Space Research Organisation(ISRO) to enhance meteorological observation and forecasting. The satellite features an improvedimaging system and an atmospheric sounder, which are crucial for retrieving detailed vertical profilesof temperature and humidity, essential for weather prediction and climate studies.The imager on INSAT-3D provides high-resolution images of the Earth’s disk from a geostationaryorbit. It includes multiple spectral bands: visible, shortwave infrared (SWIR), middle infrared (MIR),water vapor (WV), and thermal infrared (TIR). The visible band offers a high-resolution view of cloudsand surface features, while the SWIR band helps in distinguishing between land and clouds. The MIRband provides thermal imaging, and the WV band monitors atmospheric moisture. The TIR bandsare used to estimate sea surface temperatures and atmospheric temperatures.The sounder on INSAT-3D consists of 19 channels, including one visible and 18 infrared channels.It provides vertical profiles of temperature and humidity, aiding in the creation of three-dimensionalatmospheric maps. The sounder enables vertical soundings with a ground resolution of 10 km everythree hours, measuring atmospheric profiles that are crucial for weather and climate models. It alsohelps in determining various parameters such as atmospheric water vapor content and total columnozone amount.Given Below is the list of all channels and their corresponding wavelength and bandwidth thatwere present in INSAT-3D products.2Band No.Band NameCenter wavelength µmBandwidth µm1LWIR114.68010.2812LWIR214.32110.2683LWIR314.0360.2564LWIR413.64440.2985LWIR513.34020.2866LWIR612.60060.4817LWIR712.00160.7238MWIR111.01010.6089MWIR29.69260.23510MWIR37.43810.30411MWIR47.05310.39412MWIR56.5310.25513SWIR14.61130.04814SWIR24.5390.04715SWIR34.47810.045616SWIR44.15090.068317SWIR54.00940.066318SWIR63.79030.1419VIS0.6950.05Table 1: Band Names and their corresponding attributes taken from Data Files4Image ProcessingImage processing using INSAT-3D sounder L1B data is a vital process in extracting detailed atmo-spheric information. From basic preprocessing to advanced image enhancement and false color com-positing, these techniques enable the effective visualization and analysis of atmospheric conditions.The Sounder L1B data contains GeoX, GeoY, Latitude, Longitude, SND (Band Name) and somemore attributes. GeoX and GeoY are one dimensional array of numbers having 384 and 320 valueswhich corresponds to the X-axis and Y-axis of the image. If we arrange this in a 2 dimensional fashionwe get an area of 384 by 320 pixels. Now each pixel is assigned a value called GreyCount or FillValuewhich has a maximum possible value of 16383 (for Infrared Spectrum) and 4096 (for Visible one). This2D array of numbers we get is essentially the SND (Band Name). Similarly, Latitude and Longitudeare also a 2D array with the pixel or fillValue being the coordinates as per the satellite projection. Togenerate the images from the data available we have to assign the 2 dimensional array to a variableand then extract data of each pixel value and plot it on screen. This produces an Image of dimension384,320 which can furthur be used for analysis or evaluation. Given Below are images achieved afterrunning the python code for every Channel for the Sounder:LWIR1LWIR23LWIR3LWIR4LWIR5LWIR6LWIR7MWIR14MWIR2MWIR3MWIR4MWIR5SWIR1SWIR25SWIR3SWIR4SWIR5SWIR6VISFigure 5: Images from the Sounder Channels6Python CodeGiven Below is the Python Code used for deriving the above results :# -----------------Libraries ----------------#import os#Using to get filelocation.importh5py#Using forimportingnecessarydata from hdf files.importmatplotlib.pyplot as plt #Used forprocessingandplottingthe images.from PIL importImage as img#Same as above.importnumpy as np# ----------------------------------------## ----------DeclaredVariables ---------------#path= r"D:\ Summer<em>Project</em>File \JUN<em>INSAT</em>3D<em>I "#Path of theresourcefolder.directory = r"D:\ Order</em>Insat<em>3d\ Images</em>Visible"#OutputfolderPath.# ------------------------------------------## -----------Necessaryfunctions ------------#deffile<em>name(path):#To get the filesname.globallistlist =[]forfile</em>name in os.listdir(path):list.append(file<em>name)returnlistdeffile</em>viewer(path):#Forviewingthecontentinside the file.for i in file<em>name(path):file2read = h5py.File(f’{path }{i}’,’r’)returnfile2read.keys ()deffile</em>maker(directory):#Createsthedirectory.if not os.path.exists(directory):os.makedirs(directory)os.chdir(directory)def save(i,img<em>arr):plt.imsave(os.path.join(f"{directory}",f"pp</em>{i+1}. png"),img<em>arr ,cmap = ’gray ’)# plt.savefig(os.path.join(f"{ directory }",f"pp</em>{i}.png"))# fig.canvas.draw ()# buf = fig.canvas.tostring<em>rgb ()# width , height = fig.canvas. get</em>width<em>height ()# pil</em>image = img.frombytes ("RGB", (width , height), buf)# #Save PIL Image as PNG# pil<em>image.save(os.path.join(f"{ directory }",f"pp</em>{i}.png"))defprocess(directory):#mainstuffhere!for i in range(len(list)):#To test you can set the range to2 or more.7f =h5py.File(f’{path }{ list[i]}’)image = "SND<em>VIS"img</em>arr = f[image ][0 ,: ,:]##SuperImportant ### x = [element [1] forelement in img<em>arr]# y = [element [2] forelement in img</em>arr]# fig ,ax = plt.subplots (1,2, figsize =(10 ,10))# # plt.suptitle(f’raw imagedatanumber {i+1} and date {list[i][6:20]} ’ ,y = .8)# ax [0]. imshow(img<em>arr , cmap=’gray ’)# ax [0]. set</em>title (" Grey ")# ax [1]. imshow(img<em>arr , cmap=’plasma</em>r ’)# ax [1]. set<em>title (" Colored ")plt.title(f’Imagenumber :{i}, Date/Time: {list[i][6:20]} ’)img</em>arr<em>fill = f[image ]. attrs[’</em>FillValue ’][0]img<em>arr</em>m = np.ma.masked<em>equal(img</em>arr , img<em>arr</em>fill , copy=True)img1 = plt.imshow(img<em>arr</em>m , cmap="gray")#plt.colorbar(im)file<em>maker(directory)save(i,img</em>arr<em>m)print(f"In process {i+1}th file")#plt.show ()#Comment it out if gettingannoyed!plt.close ()# -------------------------------------------## -----------Running the Script ----------------#print(file</em>viewer(path))file<em>name(path)# initializingthe list of files.file</em>maker(directory)#Check fordirectory.process(directory)#Start theProcessand Wait.# ---------------------------------------------#This Code Generates Images of the specified Channels, each image can be stored in a folder andafter getting large amount of images we can generate a animation out of the images by stitching themtogether using ffmpeg. this folowing command can be used to generate the animations :ffmpeg -framerate 15 -i image %d.png -r 60 -y clouds.mp4Since this is a pdf document it is impossible to show and run animations. But, animations alsoplays a very crucial role in predicting the trajectories of clouds,storms,hurricanes and with use of AIand Machine learning we can enhance on this area.8Error FixingWhile Looking through every images produced by the program above, we sometimes see a dimming andwhitening of the whole image which can change the meaning of the image obtained as the whiteningof the image/ the white pixels represents the reflection of light although its a grey-scale image whichmeans the white shifted pixels shoes a bias to reflection of light which can later interfere with thealgorithms to convert these brightness/ reflected values into temperature to show wrong temperature.This brightening of the whole image is due to presence of a very large pixel value which create abias in the image (it can be seen as a very dark pixel). Although the algorithm that we are going touse below for temperature generation uses pixel values at a time which will rule out error pixel andwill not interfere with neighbouring pixels. But, this error has a significant effect on false coloring as itmay increases the intensity of a single channel making the image unable to read. Also it is to be notedthat this error occurs mostly at a particular time i.e. 19:00 o’clock and this error is mostly present atthe same position as observed before or after. We do not have any specific explanation for this error.The images with this error looks like this :Figure 6: Observed ErrorsTo resolve this error, we used a very simple algorithm which measures the value of each pixel presenton the image and determine two important parameters : Mean and Standard Deviation. Which isfurther used to find the outliers in the dataset present. Generally, the outlier pixel value is more thanthe standard deviation observed of the whole dataset, but to be cautious , some constant is multipliedto this to only select the outliers. Since, the outlier has a very large value, we can replace the pixelvalue to the average of its neighbouring pixel values.9Below is the result obtained by applying this process:Figure 7: Error CorrectedBelow is the code for the above stated:Python Codeimporth5pyimportmatplotlib.pyplot as pltimportnumpy as nppath= r"D:\ Summer<em>Project</em>File \JUN<em>INSAT</em>3D<em>I \3DSND</em>01JUN2019<em>1900</em>L1B<em>SA1</em>V01R00 .h5"#To test you can set the range to 2 or more.with h5py.File(f’{path}’) as f:img<em>arr = f["SND</em>SWIR5"][0 ,: ,:]print(img<em>arr.shape)print(type(img</em>arr))10def issue(img<em>arr):global x,zx=np.mean(img</em>arr)z=np.std(img<em>arr)return (x,z)print(issue(img</em>arr))plt.plot(img<em>arr)plt.hlines(x ,0 ,380)plt.hlines(x+ 2 * z ,0 ,380)plt.hlines(x- 2 * z ,0 ,380)plt.show ()plt.imshow(img</em>arr ,cmap=’gray ’)plt.show ()for i in range (320):for j in range (384):if img<em>arr[i][j] &lt;= x- 2 * z:img</em>arr[i][j]= (img<em>arr[i -1][j] + img</em>arr[i+1][j] )/2else:Noneplt.plot(img<em>arr)plt.show ()plt.imshow(img</em>arr , cmap=’gray ’)plt.title(f’Imagenumber :1, Date/Time: {path [42:56]} ’)plt.imsave(f"img.png",img<em>arr ,cmap = ’gray ’)plt.show ()115False ColoringAn image typically consists of three primary channels: Red, Green, and Blue. Most of the times Alphachannel is included for transparency, but for simplicity it is not a requirement here .When we observethe image products derived from the various channels individually, they appear to be in grey-scale.However, on combining these grey-scale images as individual and unique channels of a single image , wecan produce visually striking and colorful images. False coloring is a technique which is used to applycolors to a grey-scale image, giving it the appearance of a full-color image. In our scenario, we havegrey-scale images from the different channels that can be combined to create a false-color composite.For our false coloring process, we use the following channels: LWIR7 as the Red channel, SWIR1 asthe Blue channel, and SWIR2 as the Green channel. By merging these different channels into a singleimage, we produce a vibrant, false-colored image that enhances the visuals . The resulting image isshown below.(a) LWIR7: Red Channel(b) SWIR1: Blue Channel(c) SWIR2: Green ChannelFigure 8: False Coloring ChannelsFigure 9: The Colored Image12Python CodeGiven below is the code for reproducing the above results. And by changing the sounder channels ofthe respective color channels, different results can be achieved.import osimport cv2importmatplotlib.pyplot as pltdef save(i):plt.imsave(os.path.join(f"{directory}",f"pic</em>prod{i+1}. png"),image)plt.savefig(os.path.join(f"{directory}",f"pic<em>{i}.png"))directory = "D:\ Summer</em>Project<em>Output \Color</em>Product"for i in range (1): # Number of itterations or No of Imagesimg = cv2.imread(f"D:\ Order<em>Insat</em>3d \ Images<em>LWIR7</em>prod {i}.png")#redimg<em>1 = cv2.imread(f"D:\ Order</em>Insat<em>3d\ Images</em>SWIR1<em>prod {i}.png")#blueimg</em>2 = cv2.imread(f"D:\ Order<em>Insat</em>3d\ Images<em>SWIR2</em>prod {i}.png")#greenprint("image no : ", i+1)r, <em>, _ = cv2.split(img)# plt.imshow(r)</em>, g, _ = cv2.split(img<em>2)# plt.imshow(g)</em>, <em>, b = cv2.split(img</em>1)# plt.imshow(b)# print(r,b,g)# print(’Shape of red channel--> ’, r.shape)# print(’Shape of greenchannel--> ’, g.shape)# print(’Shape of bluechannel--> ’, b.shape)image= cv2.merge ((r, g, b))plt.imshow(image)plt.title(’ColoredVersion ’)save(i)plt.show ()136Data Projection on the MapThe Sounder of both INSAT-3D and INSAT-3DR satellites produces a 320 by 384 pixel grid. Whichare anchored using the latitude and longitude data. Both L1B and L2B processed files are projectedby this process of anchoring/associating pixel data with latitude and longitude aka coordinates. OnlyL1C files have a grid base system [INSa] Hence, the approach is to first create a map of latitude andlongitude which is later assigned the pixel values. Which later can be projected on a map or a globe.For this program I have used Cartopy, which is a python library for plotting maps.The thing is to be noted that sometimes data type may vary , here is this case the latitude andlongitude values were in ”short” datatype, which is need to be converted to ”float” datatype for properuse and applying to the maps.Given Below are some results that have been obtained using the program.Figure 10: Data Projected on platecarree map projection14Figure 11: Data Projected on platecarree map projectionFigure 12: Data Projected on Geostationary map projection15Python Codeimporth5pyimportnumpy as npimportmatplotlib.pyplot as pltimportcartopy.crs as ccrsimportcartopy.feature as cfeatureimport PIL.Image as imgimport os# Define the path to the HDF5 file# img1 = np.asarray(img.open ("D:\ Order<em>Insat</em>3d\ Images<em>LWIR7</em>prod \img.png",’r ’))# print(type(img1), img1.shape)path = r"D:\ Summer<em>Project</em>File \JUN<em>INSAT</em>3D<em>I "deffile</em>name(path):#To get the filesname.globallistlist =[]forfile<em>name in os.listdir(path):list.append(file</em>name)returnlistfile<em>name(path)defadd</em>decimal<em>to</em>int16 (number):# Convert the number to a stringnum<em>str = str(number)# Insert the decimalpoint twopositionsfrom the rightif len(num</em>str) &gt; 2:result = num<em>str [:-2] + ’.’ + num</em>str [-2:]elif len(num<em>str) == 2:result = ’0.’ + num</em>strelse:result = ’0.0’ + num<em>str# Convert to floatreturnfloat(result)defconvert</em>array<em>to</em>float (array):float<em>array = np.zeros</em>like(array , dtype=np.float32)for i in range(array.shape [0]):for j in range(array.shape [1]):float<em>array[i, j] = add</em>decimal<em>to</em>int16 (array[i, j])returnfloat<em>arrayplt.tight</em>layout ()# Open the HDF5 filefor i in range(len(list)):f = h5py.File(f’{path }{ list[i]}’)image = ’SND<em>LWIR7 ’img</em>arr = f[image ][0, :, :]# Get<em>FillValuefor datamaskingimg</em>arr<em>fill = f[image ]. attrs[’</em>FillValue ’][0]# print(f"<em>FillValue: {img</em>arr<em>fill }")# Retrieveextent of plot from fileattributes16left</em>lon= f.attrs[’left<em>longitude ’][0]right</em>lon = f.attrs[’right<em>longitude ’][0]lower</em>lat = f.attrs[’lower<em>latitude ’][0]upper</em>lat = f.attrs[’upper<em>latitude ’][0]sat</em>long=f.attrs[’Nominal<em>Central</em>Point<em>Coordinates (degrees)</em>Latitude<em>Longitude ’][1]sat</em>lat =f.attrs[’Nominal<em>Central</em>Point<em>Coordinates (degrees)</em>Latitude<em>Longitude ’][0]sat</em>hght=f.attrs[’Observed<em>Altitude (km)’][0] * 1000.0#Convert to meters# Retrieveattributes to calculateradiancefromcountSensor</em>Name = f.attrs[’Sensor<em>Name ’]. decode(’utf -8’)print(f"SensorName: {Sensor</em>Name}")geo<em>x = f[’GeoX ’].len()geo</em>y = f[’GeoY ’].len()lon = f[’Longitude ’][:, :]lat = f[’Latitude ’][:, :]# print(lat[:,:],lon.shape)lon<em>float = convert</em>array<em>to</em>float (lon)lat<em>float = convert</em>array<em>to</em>float (lat)# print(lat<em>float)print(’DonereadingHDF5 file ’)print(f"SatellitePosition: Latitude {sat</em>lat}, Longitude {sat<em>long}")# Mask ’</em>FillValue ’ data in the imagearrayimg<em>arr</em>m = np.ma.masked<em>equal(img</em>arr , img<em>arr</em>fill , copy=True)# Set up projectionsmap<em>proj = ccrs.Geostationary( central</em>longitude =sat<em>long ,satellite</em>height =sat<em>hght)data</em>crs = ccrs.PlateCarree( central<em>longitude =sat</em>long)# Plottingplt.figure(figsize =(10, 10))ax1 = plt.axes(projection=map<em>proj)# ax1.add</em>feature(cfeature.BORDERS)ax1.coastlines(resolution=’50m’)# ax1.add<em>feature(cfeature.BORDERS , edgecolor=’white ’,linewidth =0.5)ax1.gridlines(color=’black ’, alpha =0.5,linestyle=’--’,linewidth =0.75 ,draw</em>labels=True)map<em>proj</em>text = f’{str(type(map<em>proj)).split (".") [ -1][: -2]} ’data</em>crs<em>text = f’{str(type(data</em>crs)).split (".") [ -1][: -2]} ’plt.title(f’Data: {image} (masked) \n Date: {list[i][6:20]} \n’)print(left<em>lon , right</em>lon , lower<em>lat , upper</em>lat)im2 = ax1.contourf(lon<em>float [:,:], lat</em>float [:,:], img<em>arr</em>m ,transform=ccrs.PlateCarree ())ax1.scatter (77.1025 ,28.7041 ,transform=ccrs.PlateCarree (),17color=’red’, marker=’o’)# Examplecoordinatesfor New Delhi# ax1.scatter(x,y, transform=ccrs.PlateCarree(sat<em>long), color=’blue ’, marker=’o ’)ax1.set</em>extent ([ left<em>lon -10, right</em>lon +10, lower<em>lat -6,upper</em>lat +10])# cbar = plt.colorbar(im2 , ax=ax1 , orientation=’vertical ’,fraction =0.046 , pad =0.04)# cbar.set<em>label ("<Info here &gt;\n", rotation = 270)plt.savefig(f"Image</em>{i}")plt.close ()f.close ()plt.show ()plt.show ()Listing 1: Python code to process HDF5 files and generate plots187Finding the temperature!It is only possible to find the brightness temperature instead of regular temperature from a distantlocation, as satellites don’t directly measure temperature or the surface. Instead, they measure thebrightness of Earth’s atmosphere.Brightness Temperature represents the temperature of a black body that would emit the sameamount of radiance at a given wavelength. It is a measure of the radiance of a surface as perceivedby a remote sensing instrument, such as a satellite sensor. Unlike physical temperature, brightnesstemperature is derived from the radiative properties of the object and is influenced by factors such asemissivity and atmospheric absorption. Hence, Brightness temperature is always less than or equalsto Surface temperature.To obtain the Brightness temperature we use Inverse Planck’s law, which uses measured emittedradiance to calculate Brightness temperature.T =hcλk ln2hc2λ5B(λ,T ) + 1• B(λ, T): Spectral radiance at wavelength λ and temperature T.• h: Planck’s constant (6.6260755 × 10−34 J·s).• c: Speed of light in a vacuum (2.9979246 × 108 m/s).• λ: Wavelength.• k: Boltzmann’s constant (1.380658 × 10−23 J/K).• T: Absolute temperature of the black body.In the article [INSb], a method is given to derive radiance from the ”Online Radiance Quad” and”count” which uses onboard sensors to calculate the Radiance. For further reading see this paper:[BKKSP16].Below are some plots derived from the python program.Figure 13: Temperature Gradient Of India in SWIR6 Band19Figure 14: Temperature Gradient Of India in SWIR6 BandPython Codeimporth5pyimportmatplotlib.pyplot as pltimportnumpy as npfrompylabimport cmimport PIL.Image as imgpath= r"D:\ Summer<em>Project</em>File \Jun24<em>103187 \3RSND</em>01JUN2019<em>0200</em>L1B<em>SA1</em>V01R00 .h5"f= h5py.File(path)image = ’SND<em>SWIR6 ’img</em>arr = f[image ][0 ,: ,:]img<em>arr</em>fill = f[image ]. attrs[’<em>FillValue ’][0]img</em>arr<em>m = np.ma.masked</em>equal(img<em>arr , img</em>arr<em>fill , copy=True)loco = f[image ]. attrs.get(’invert ’)# if loco == b’true ’:#print ("Yes")poco = f[image ]. attrs.get(’online</em>radiance<em>quad ’)print(loco)print(poco)def issue(img</em>arr):global x,y,zx=np.mean(img<em>arr)y=np.median(img</em>arr)z=np.std(img<em>arr)return (x,y,z)print(issue(img</em>arr))for i in range (320):20for j in range (384):if img<em>arr[i][j] &lt;= x- 2 * z:img</em>arr[i][j]= (img<em>arr[i -1][j] + img</em>arr[i+1][j] )/2else:Noneo<em>r</em>q = f[image ]. attrs.get(’online<em>radiance</em>quad ’)[0]o<em>r</em>s<em>f = f[image ]. attrs.get(’online</em>radiance<em>scale</em>factor ’)[0]o<em>r</em>a<em>o = f[image ]. attrs.get(’online</em>radiance<em>add</em>offset ’)[0]print(o<em>r</em>q ,o<em>r</em>s<em>f ,o</em>r<em>a</em>o)# Findingradianceforcalculatingtemprature#R = o<em>r</em>q * (count)^2 +o<em>r</em>s<em>f * count + o</em>r<em>a</em>odefradiance(img<em>arr , o</em>r<em>q , o</em>r<em>s</em>f , o<em>r</em>a<em>o):# Initializethe resultarray r with the samedimensions asimg</em>arrr = [[0 for _ in range(len(img<em>arr [0]))] for _ in range(len(img</em>arr))]globalrad<em>w</em>m2rad<em>w</em>m2 = [[0 for _ in range(len(img<em>arr [0]))] for _ in range(len(img</em>arr))]for i in range(len(img<em>arr)):for j in range(len(img</em>arr[i])):if f[image ]. attrs.get(’invert ’) == b’true ’:img<em>arr[i][j] = 16383 - img</em>arr[i][j]else:Noner[i][j] = o<em>r</em>q * (img<em>arr[i][j])<strong>2 + o</em>r<em>s</em>f * (img<em>arr[i][j]) + o</em>r<em>a</em>o# print(r[i][j])rad<em>w</em>m2[i][j] = (o<em>r</em>q * (img<em>arr[i][j])</strong>2 + o</em>r<em>s</em>f * (img<em>arr[i][j]) + o</em>r<em>a</em>o) <em>10return rhot = radiance(img_arr_m ,o_r_q , o_r_s_f , o_r_a_o)# plt.imshow(hot , origin = ’upper ’)# plt.colorbar ()# plt.show ()# brightness_temperature = C2 / (cwl * log(C1 / (1.0 E6 * rad_w_m2 *pow (cwn , 5.0)) + 1))central_wavelength = f[image ]. attrs.get(’central_wavelength ’)[0]cwl= central_wavelength /1000000.0# (Fieldcentral_wavelength inproduct)h = 6.6260755e-34c = 2.9979246e+821k = 1.380658e-23C1 = 2.0 * h *c * cC2 = (h * c) / kprint(cwl)def temp ():bt = [[0 for _ in range(len(img_arr_m [0]))] for _ in range(len(img_arr_m))]for i in range(len(img_arr_m)):for j in range(len(img_arr_m[i])):bt[i][j] = C2 / (cwl * np.log(C1 / (1.0 E6 * rad_w_m2[i][j]</em> pow (cwl , 5.0)) + 1))# if bt[i][j]== ’masked ’:#bt[i][j]= ’Nan’return bthot= temp ()f.close ()cmap= cm.get<em>cmap(’Spectral</em>r ’)# norm = Normalize(vmin =240, vmax =320)plt.imshow(hot , origin= ’upper ’, cmap=cmap)# plt.title(f"{ image }")# cbar = plt.colorbar ()# cbar.set<em>label (" Temprature in K", rotation = 270)plt.axis(’off’)plt.savefig(’out</em>R<em>SWIR6.png’, bbox</em>inches=’tight ’, pad<em>inches =0)# plt.imsave(’out</em>LWIR1.png ’,hot)plt.show ()plt.close ()Listing 2: Python code to process generate Tempratue plots228INSAT L2B Dataset UsageThe INSAT-3D satellite is equipped with an 18-channel infrared sounder and a visible channel, designedto retrieve vertical profiles of atmospheric temperature and moisture, as well as total column ozonecontent, from clear-sky infrared radiances observed in various absorption bands. The sounder-derivedprofiles include temperature and water vapor data at 40 vertical pressure levels, ranging from thesurface to approximately 70 km. The application products derived from these atmospheric profiles canbe accessed at https://mosdac.gov.in/doi/136/.9Vertical Temperature and Water Vapor/Moisture ProfilesVertical profiles of temperature and water vapor (or moisture) are crucial for understanding the atmo-spheric structure and dynamics. These profiles help us to analyze weather patterns, predict climatechanges, and study atmospheric processes. This section presents an analysis of vertical temperatureand moisture profiles derived from INSAT-3D and INSAT-3DR satellites observations over a specifiedperiod. The profiles are divided into 40 vertical pressure levels (in hPa) as follows:1000, 950, 920, 850, 750, 700, 670, 620, 570, 500, 475, 430, 400, 350, 300, 250, 200, 150,135, 115, 100, 85, 70, 60, 50, 30, 25, 20, 15, 10, 7, 5, 4, 3, 2, 1.5, 1, 0.5, 0.2, 0.1To generate vertical profiles, it is essential to specify a geolocation that centers the area of interest.In this analysis, Delhi is used as the focal point. If specific geolocation data is not available, it wouldbe beneficial to visualize vertical profiles as contour plots over the whole area. Then theses contourplots can be stacked on each other making a onion layer effect. see figure 17In the graphs plotted as shown in figure 15 and figure 16, The altitude (y-axis) represents height,ranging from sea level (1000 hPa) to the stratosphere (0.1 hPa, approximately 37 km above thesurface).And in figure 17 due to hardware limitations, only 6 layers are shown in the image below,although the full dataset includes 40 slices.Few important points about these plots should be noted:The scan periods of the two satellitesdiffer, resulting in a time delay between the datasets (typically around 1 hour).The data used in theseplots is sourced from the L2B geo-physical dataset, which includes an algorithm that masks cloud-covered surface areas, leaving only a limited area for data points/pixels.If temperature profile data forspecific coordinates, such as Delhi, is unavailable, nearby non-zero valued pixels are utilized. Eachpixel represents an area of 10 km, so the difference should be generally minimal.23Given Below are some results that have been obtained:Figure 15: Temperature Profile of DelhiFigure 16: Humidity Profile plot of DelhiAnd to make this visually appealing we can produce these as a sliced layer plot over the desired surfacearea.24Figure 17: Onion Layer Vertical Temperature PlotPython Codeimportnumpy as npimportmatplotlib.pyplot as pltfrommatplotlibimport <em>frommpl_toolkits.mplot3dimportAxes3Dimporth5pyfrommatplotlibimport cmm = cm. ScalarMappable(cmap=cm.jet)# globals ()[’image_L%s’ %i] = plt.imread(f"D:\ SummerProject\out_LWIR{i+1}. png")# Forcreatingrun timevarible to storethe Images# globals ()[’image_M%s’ %i] = plt.imread(f"D:\ SummerProject\out_LWIR{i+1}. png")# Put these in a for loop for useage# globals ()[’image_S%s’ %i] = plt.imread(f"D:\ SummerProject\out_LWIR{i+1}. png")# globals ()[’imageeR%s’ %i] = plt.imread(f"D:\ SummerProject\geo_heat_map_R {i}.png")imageeR1=plt.imread(f"D:\ SummerProject\ geo_heat_map_R1 .png")imageeR2=plt.imread(f"D:\ SummerProject\ geo_heat_map_R6 .png")imageeR3=plt.imread(f"D:\ SummerProject\ geo_heat_map_R12 .png")imageeR4=plt.imread(f"D:\ SummerProject\ geo_heat_map_R18 .png")imageeR5=plt.imread(f"D:\ SummerProject\ geo_heat_map_R24 .png")imageeR6=plt.imread(f"D:\ SummerProject\ geo_heat_map_R32 .png")imageeR7=plt.imread(f"D:\ SummerProject\ geo_heat_map_R36 .png")imagee1=plt.imread(f"D:\ SummerProject\geo_heat_map_1 .png")imagee2=plt.imread(f"D:\ SummerProject\geo_heat_map_6 .png")imagee3=plt.imread(f"D:\ SummerProject\ geo_heat_map_12 .png")imagee4=plt.imread(f"D:\ SummerProject\ geo_heat_map_18 .png")imagee5=plt.imread(f"D:\ SummerProject\ geo_heat_map_24 .png")imagee6=plt.imread(f"D:\ SummerProject\ geo_heat_map_32 .png")imagee7=plt.imread(f"D:\ SummerProject\ geo_heat_map_36 .png")25path = r"D:\ Summer_Project_File \JUN_INSAT_3D \3DSND_01JUN2019_0600_L2B_SA1_V01R00 .h5"path2= r"D:\ Summer_Project_File \Jun24_103187 \3RSND_01JUN2019_0900_L2B_SA1_V01R00 .h5"defadd_decimal_to_int16 (number):# Convert the number to a stringnum_str = str(number)# Insert the decimalpoint twopositionsfrom the rightif len(num_str) &gt; 2:result = num_str [:-2] + ’.’ + num_str [-2:]elif len(num_str) == 2:result = ’0.’ + num_strelse:result = ’0.0’ + num_str# Convert to floatreturnfloat(result)# Open the HDF5 filef = h5py.File(path , ’r’)f2 = h5py.File(path2 , ’r’)image = ’TAirReg ’img_arr = f[image ][0,:, :, :]skin_temp = ’TSurfReg ’humidity= ’H2OMMRFG ’img_hot = f[skin_temp ][0 ,: ,:]# Get_FillValuefor datamaskingimg_arr_fill = f[image ]. attrs[’_FillValue ’][0]# Mask ’_FillValue ’ data in the imagearrayimg_arr_m = np.ma.masked_equal(img_arr , img_arr_fill , copy=True)img_hot_m = np.ma.masked_equal(img_hot , img_arr_fill , copy=True)geo_x = f[’GeoX ’].len()geo_y = f[’GeoY ’].len()lon = f[’Longitude ’][:, :]lat = f[’Latitude ’][:, :]lon1 = f[’Longitude ’][:, :]lat1 = f[’Latitude ’][:, :]data = [f[image ][0,i ,191 ,98] for i in range (40)]data.reverse ()print(f[skin_temp ][0 ,191 ,98])# data.insert (0,f[skin_temp ][0 ,191 ,98])# print(data)data2 = [f2[image ][0,i ,191 ,98] for i in range (40)]data2.reverse ()print(data2)# data2.insert (0,f2[skin_temp ][0 ,191 ,98])# Function to convert the array to floatwith thedecimaladjustmentdefconvert_array_to_float (array):26float_array = np.zeros_like(array , dtype=np.float32)for i in range(array.shape [0]):for j in range(array.shape [1]):float_array[i, j] = add_decimal_to_int16 (array[i, j])returnfloat_array# Convert the lon array to floatwith theadjusteddecimallon_float = convert_array_to_float (lon)lat_float = convert_array_to_float (lat)lon_float1 = convert_array_to_float (lon1)lat_float1 = convert_array_to_float (lat1)# Print the type of someelements to confirmprint(type(lon_float [0, 0]))print(lon_float)print(lat_float)coordinates = np.zeros ((geo_y , geo_x , 2), dtype=np.float32)coordinates1 = np.zeros ((geo_y , geo_x , 2), dtype=np.float32)for i in range(geo_y):for j in range(geo_x):coordinates[i, j] = [lon_float[i, j], lat_float[i, j]]coordinates1[i, j] = [lon_float1[i, j], lat_float1[i, j]]# Printsomecoordinatepairs to verifyprint(coordinates [0, 0])# Print the firstcoordinatepairprint(coordinates [98 ,191])# Printanothercoordinatepairdelhi_coords = [77.1025 ,28.7041]# # Calculatedifferencesand find theclosestmatchdifferences = np.sqrt (( coordinates [:,:,0] - delhi_coords [0]) *</em>2 +(coordinates [:,:,1] - delhi<em>coords [1]) **2)differences1 = np.sqrt (( coordinates1 [:,:,0] - delhi</em>coords [0]) <em>*2+ (coordinates1 [:,:,1] - delhi_coords [1]) *</em>2)min<em>index = np.unravel</em>index(np.argmin(differences), differences.shape)min<em>index1 = np.unravel</em>index(np.argmin(differences1),differences1.shape)# Print the closestcoordinateand itspositionprint("Closestcoordinate:", coordinates[min<em>index ])print("Position (row , col):", min</em>index)# Print the closestcoordinateand itspositionprint("Closestcoordinate:", coordinates1[min<em>index1 ])print("Position (row , col):", min</em>index1)# print(img<em>arr</em>m)fig ,ax = plt.subplots (2,2, squeeze=False)# plt.suptitle(’TemperatureProfile (k) ’)# ax [0][1]. YDir = ’reverse ’height =[1000 ,950 ,920 ,850 ,780 ,700 ,670 ,620 ,570 ,500 ,475 ,430 ,400 ,350 ,300 ,250 ,200 ,150 ,135 ,11527print(len(height))# error = np.array(data) - np.array(data2)x = [a for a in range(len(height))]ax [0][0]. scatter(data ,height)ax [0][0]. plot(data ,height)ax [0][0]. set<em>title("From INSAT -3D")ax [0][0]. set</em>xlabel("Temperature (k)")ax [0][0]. set<em>ylabel("Pressure (hPa)")# ax [0][0]. set</em>yticklabels (height)ax [0][0]. invert<em>yaxis ()ax [1][0]. scatter(data ,x)ax [1][0]. plot(data ,x)ax [1][0]. set</em>title("From INSAT -3D (Scaled)")ax [1][0]. set<em>xlabel("Temperature (k)")ax [1][0]. set</em>ylabel("AltitudeLevel ")# ax [0][0]. set<em>yticklabels (height)# ax [1][0]. invert</em>yaxis ()ax [0][1]. scatter(data2 ,height [:])ax [0][1]. plot(data2 [:], height)ax [0][1]. set<em>title("From INSAT -3DR")ax [0][1]. set</em>xlabel("Temperature (k)")ax [0][1]. set<em>ylabel("Pressure (hPa)")# ax [0][1]. set</em>yticklabels (height)ax [0][1]. invert<em>yaxis ()ax [1][1]. scatter(data2 ,x)ax [1][1]. plot(data2 [:],x)ax [1][1]. set</em>title("From INSAT -3DR (Scaled)")ax [1][1]. set<em>xlabel("Temperature (k)")ax [1][1]. set</em>ylabel("AltitudeLevel")# ax [0][1]. set<em>yticklabels (height)# ax [1][1]. invert</em>yaxis ()plt.tight<em>layout ()data = [f[humidity ][0,i ,191 ,97] for i in range (40)]data.reverse ()data2 = [f2[humidity ][0,i ,191 ,97] for i in range (40)]data2.reverse ()fig ,ax = plt.subplots (1,2, squeeze=False)plt.suptitle(’HumidityProfile (g/kg)’)ax [0][0]. scatter(data ,height)ax [0][0]. plot(data ,height)ax [0][0]. set</em>title("From INSAT -3D")ax [0][0]. set<em>xlabel("Humidity (g/kg)")ax [0][0]. set</em>ylabel("Pressure (hPa)")# ax [0][0]. set<em>yticklabels (height)ax [0][0]. invert</em>yaxis ()ax [0][1]. scatter(data2 ,height [:])ax [0][1]. plot(data2 [:], height)ax [0][1]. set<em>title("From INSAT -3DR")28ax [0][1]. set</em>xlabel("Humidity (g/kg)")ax [0][1]. set<em>ylabel("Pressure (hPa)")# ax [0][1]. set</em>yticklabels (height)ax [0][1]. invert<em>yaxis ()plt.tight</em>layout ()### VerticalyStackedImages Of TempratureMap ##### fig = plt.figure ()fig = plt.figure(figsize =(16, 12))Z = np.zeros<em>like(lon)ax = fig.add</em>subplot (1,2,1, projection=’3d’)ax.set<em>title("INSAT -3D")ax.plot</em>surface(lon<em>float ,lat</em>float , Z,rstride =1, cstride =1,facecolors = imagee1)ax.plot<em>surface(lon</em>float ,lat<em>float , Z-0.1, rstride =1, cstride =1,facecolors = imagee2)ax.plot</em>surface(lon<em>float ,lat</em>float , Z-0.2, rstride =1, cstride =1,facecolors = imagee3)ax.plot<em>surface(lon</em>float ,lat<em>float , Z-0.3, rstride =1, cstride =1,facecolors = imagee4)ax.plot</em>surface(lon<em>float ,lat</em>float , Z-0.4, rstride =1, cstride =1,facecolors = imagee5)ax.plot<em>surface(lon</em>float ,lat<em>float , Z-0.5, rstride =1, cstride =1,facecolors = imagee6)ax.plot</em>surface(lon<em>float ,lat</em>float , Z-0.6, rstride =1, cstride =1,facecolors = imagee7)plt.axis(’off’)ax.set<em>xlabel(’latitude ’)ax.set</em>ylabel(’longitude ’)ax.set<em>zlabel(’Layers ’)ax2 = fig.add</em>subplot (1,2,2, projection=’3d’)ax2.set<em>title(’INSAT -3DR’)ax2.plot</em>surface(lon<em>float1 ,lat</em>float1 , Z,rstride =1, cstride =1,facecolors = imageeR1)ax2.plot<em>surface(lon</em>float1 ,lat<em>float1 , Z-0.1, rstride =1, cstride =1,facecolors = imageeR2)ax2.plot</em>surface(lon<em>float1 ,lat</em>float1 , Z-0.2, rstride =1, cstride =1,facecolors = imageeR3)ax2.plot<em>surface(lon</em>float1 ,lat<em>float1 , Z-0.3, rstride =1, cstride =1,facecolors = imageeR4)ax2.plot</em>surface(lon<em>float1 ,lat</em>float1 , Z-0.4, rstride =1, cstride =1,facecolors = imageeR5)ax2.plot<em>surface(lon</em>float1 ,lat<em>float1 , Z-0.5, rstride =1, cstride =1,facecolors = imageeR6)ax2.plot</em>surface(lon<em>float1 ,lat</em>float1 , Z-0.6, rstride =1, cstride =1,facecolors = imageeR7)ax2.set<em>xlabel(’latitude ’)ax2.set</em>ylabel(’longitude ’)ax2.set<em>zlabel(’Layers ’)plt.tight</em>layout ()29plt.show ()Listing 3: Python code to process generate verticle Tempratue and Moistue profiles10Temperature and Moisture Profiles over a period of daysAgain Temperature and moisture profiles are essential components of atmospheric studies, it providesinsight into the vertical distribution of Temperature and Moisture in the atmosphere. These profiles arecrucial for understanding weather patterns, climatic changes and environmental changes. By analyzingtemperature and moisture profiles over a period of days, we can observe and detect weather cycles,anomalies and could improve on weather forecasting models.In this section we are extending on the analysis stated in previous part by now spanning over dayson the vertical profiles.We are focusing on plotting temperature and Moisture details at key pressurelevels: 800 hPa, 500 hPa, and 200 hPa .Plots are produced by using the pixel value of the perticular given geolocation and if the original/-center pixel doesn’t have any value stored, the algorithm search for one in its neighbourhood. For thispurpose, this program uses the BFS(Breadth First Search) algorithm for finding the data.Given Below are some of the results obtained:Figure 18: Temperature data plot over a period of 5-JUL-2023 to 10-JUL-2023The python code is given below :Python Code in LaTeX Your Name August 11, 2024Python Codeimporth5pyimportmatplotlib.pyplot as pltimportnumpy as npimport osfromcollectionsimportdequepath= r"D:\ Summer<em>Project</em>File \Jul24<em>103909"deffile</em>name(path):#Toget the filesname.globallistlist =[]30Figure 19: Humidity data plot over a period of 5-JUL-2023 to 10-JUL-2023forfile<em>name in os.listdir(path):list.append(file</em>name)returnlistfile<em>name(path)# print(list)za</em>list<em>850 , za</em>list<em>500 , za</em>list<em>200=[] ,[] ,[]hum</em>850 , hum<em>500 , hum</em>200 = [] ,[] ,[]za<em>dev</em>850 , za<em>dev</em>500 , za<em>dev</em>200 = [], [], []hum<em>dev</em>850 , hum<em>dev</em>500 , hum<em>dev</em>200 = [], [], []# Function to find the nearest non -negativevalueusing BFSdeffind<em>nearest</em>non<em>negative</em>bfs (data , start<em>index , fill</em>value ,plevel):queue = deque ([( start<em>index [0], start</em>index [1], 0)])visited = set()directions = [(-1, 0), (1, 0), (0,-1), (0, 1), (1, 1), (1,-1),(-1,-1), (-1, 1)]# Up , Down , Left , Right , DownRight , DownLeft ,UpLeft , UpRightwhilequeue:x, y, level = queue.popleft ()if (x, y) in visited:continuevisited.add((x, y))if data[plevel , x, y] != fill<em>valueand data[plevel , x, y] &gt;=0:return (x, y), level#Commentthispiece out if no limit is set# ################################### if level &lt; 5:#Can choosethedistanceallowed to traverse eg: 5 coresponds to about 50km#for dx , dy in directions:#nx , ny = x + dx , y + dy#if 0 &lt;= nx &lt; data.shape [1] and 0 &lt;= ny &lt; data.shape[2] and (nx , ny) not in visited:#queue.append ((nx , ny , level + 1))31Figure 20: Plot of Temprature data at 850hPa with Error-bars(Data obtained at perticular distancefar from the fixed coordinates) over a period of 5-JUL-2023 to 10-JUL-2023Figure 21: Plot of Temprature data at 500hPa with Error-bars(Data obtained at perticular distancefar from the fixed coordinates) over a period of 5-JUL-2023 to 10-JUL-202332Figure 22: Plot of Temprature data at 200hPa with Error-bars(Data obtained at perticular distancefar from the fixed coordinates) over a period of 5-JUL-2023 to 10-JUL-2023Figure 23: Humidity data at 850hPa plot over a period of 5-JUL-2023 to 10-JUL-202333Figure 24: Humidity data at 500hPa plot over a period of 5-JUL-2023 to 10-JUL-2023Figure 25: Humidity data at 200hPa plot over a period of 5-JUL-2023 to 10-JUL-202334Figure 26: Temperature data(With distance fixed at 50km) plot over a period of 5-JUL-2023 to 10-JUL-2023# ###################################Commentthis out if limit/level is set# ##################################for dx , dy in directions:nx , ny = x + dx , y + dyif 0 &lt;= nx &lt; data.shape [1] and 0 &lt;= ny &lt; data.shape [2] and(nx , ny) not in visited:queue.append ((nx , ny , level + 1))# ##################################return None , Nonefor i in range(len(list)):f = h5py.File(f’{path }{ list[i]}’)image = "TAirPhy"img</em>arr = f[image ][0, :, :, :]image1 = "H2OMMRPhy"img<em>arr</em>0 = f[image1 ][0, :, :, :]img<em>arr</em>m = np.ma.masked<em>equal(img</em>arr ,-999, copy=True)img<em>arr</em>m1 = np.ma.masked<em>equal(img</em>arr<em>0 ,-999, copy=True)if img</em>arr [36, 187, 98] ==-999:#The 36 cooresponds to pLevelof 850 hPanearest<em>non</em>negative<em>index , deviation =find</em>nearest<em>non</em>negative<em>bfs (img</em>arr , [187, 98],-999, plevel =36)# 187 and 98 are the cell/pixelcoordiantesderivedfrom thecordinates of a perticularpoint in this case: Delhi77.1025 E,28.7041 Nifnearest<em>non</em>negative<em>indexis not None:za</em>list<em>850.append(img</em>arr<em>m [36,nearest</em>non<em>negative</em>index [0],nearest<em>non</em>negative<em>index [1]])hum</em>850.append(img<em>arr</em>m1 [36,nearest<em>non</em>negative<em>index[0],nearest</em>non<em>negative</em>index [1]])35za<em>dev</em>850.append(deviation)# print(deviation)hum<em>dev</em>850.append(deviation)else:za<em>list</em>850.append(np.nan)hum<em>850.append(np.nan)za</em>dev<em>850.append (0)hum</em>dev<em>850.append (0)else:za</em>list<em>850.append(img</em>arr<em>m [36, 187, 98])hum</em>850.append(img<em>arr</em>m1 [36, 187, 98])za<em>dev</em>850.append (0)hum<em>dev</em>850.append (0)if img<em>arr [30, 187, 98] ==-999:nearest</em>non<em>negative</em>index , deviation =find<em>nearest</em>non<em>negative</em>bfs (img<em>arr , [187, 98],-999, plevel =30)ifnearest</em>non<em>negative</em>indexis not None:za<em>list</em>500.append(img<em>arr</em>m [30,nearest<em>non</em>negative<em>index [0],nearest</em>non<em>negative</em>index [1]])hum<em>500.append(img</em>arr<em>m1 [30,nearest</em>non<em>negative</em>index[0],nearest<em>non</em>negative<em>index [1]])za</em>dev<em>500.append(deviation)hum</em>dev<em>500.append(deviation)else:za</em>list<em>500.append(np.nan)hum</em>500.append(np.nan)za<em>dev</em>500.append (0)hum<em>dev</em>500.append (0)else:za<em>list</em>500.append(img<em>arr</em>m [30, 187, 98])hum<em>500.append(img</em>arr<em>m1 [30, 187, 98])za</em>dev<em>500.append (0)hum</em>dev<em>500.append (0)if img</em>arr [23, 187, 98] ==-999:nearest<em>non</em>negative<em>index , deviation =find</em>nearest<em>non</em>negative<em>bfs (img</em>arr , [187, 98],-999, plevel =23)ifnearest<em>non</em>negative<em>indexis not None:za</em>list<em>200.append(img</em>arr<em>m [23,nearest</em>non<em>negative</em>index [0],nearest<em>non</em>negative<em>index [1]])hum</em>200.append(img<em>arr</em>m1 [23,nearest<em>non</em>negative<em>index[0],nearest</em>non<em>negative</em>index [1]])za<em>dev</em>200.append(deviation)hum<em>dev</em>200.append(deviation)else:za<em>list</em>200.append(np.nan)hum<em>200.append(np.nan)za</em>dev<em>200.append (0)hum</em>dev<em>200.append (0)else:za</em>list<em>200.append(img</em>arr<em>m [23, 187, 98])hum</em>200.append(img<em>arr</em>m1 [23, 187, 98])za<em>dev</em>200.append (0)hum<em>dev</em>200.append (0)36# DatesExtractordates = [list[i][6:20] for i in range(len(za<em>list</em>850))]fig , axs = plt.subplots( figsize =(14, 18))fig.suptitle(’HumidityPlot withDeviation ’, fontsize =16)defplot<em>data(ax , title , y</em>data , y<em>label , y</em>err , dates):ax.errorbar(range(len(y<em>data)), y</em>data , yerr=y<em>err , fmt=’o’,capsize =2)ax.plot(dates ,y</em>data ,c=’blue ’)# Showeveryseconddatelabelax.set<em>xticks(range (0, len(dates), 2))ax.legend ([f’MaximumDistanceTraversed :{max(y</em>err) * 10}km’])ax. set<em>xticklabels ([ dates[i] for i in range(0, len(dates), 2)],rotation =45)ax.set</em>title(title)ax.set<em>xlabel(’Date/Time ’)ax.set</em>ylabel(y<em>label)ax.grid(True)# Plot data for eachpressurelevel andvariableplot</em>data(axs , ’TemperaturePlot at 850 hPa’, za<em>list</em>850 , ’Temperature(K)’, za<em>dev</em>850 , dates)plot<em>data(axs , ’TemperaturePlot at 500 hPa’, za</em>list<em>500 , ’Temperature(K)’, za</em>dev<em>500 , dates)plot</em>data(axs , ’TemperaturePlot at 200 hPa’, za<em>list</em>200 , ’Temperature(K)’, za<em>dev</em>200 , dates)# plot<em>data(axs , ’HumidityPlot at 850 hPa ’, hum</em>850 , ’Humidity (g/kg)’, hum<em>dev</em>850 , dates)# plot<em>data(axs , ’HumidityPlot at 500 hPa ’, hum</em>500 , ’Humidity (g/kg)’, hum<em>dev</em>500 , dates)# plot<em>data(axs , ’HumidityPlot at 200 hPa ’, hum</em>200 , ’Humidity (g/kg)’, hum<em>dev</em>200 , dates)plt.tight<em>layout(rect =[0, 0, 1, 0.96])plt. subplots</em>adjust (bottom =0.2, hspace =0.4)# Add space at the bottomandbetweenplots to avoidlabeloverlapplt.show ()Listing 4: Python code to plot the profiles at a perticular location over the period of time.The above program is also capable of making animation of plots by stitching images processedtogether over the period of time, this pdf document is incapable of showing animations hence, a fewimages are shown below:37Figure 27: Temperature PlotFigure 28: Temperature PlotThank you for Reading the Project!38Figure 29: Temperature PlotReferences[BKKSP16] Swati P. Bhatawdekar, AS Kiran Kumar, Dhiren R. Shah, and AK Padhi. Reflectance-based vicarious calibration of INSAT-3D using high resolution geostationary satellite data.Remote Sensing Applications: Society and Environment, 2:1–11, 2016.[INSa]INSAT DP Team.INSAT-3D Data Products Format Document.https://www.mosdac.gov.in/docs/INSAT3D<em>Products.pdf.Appendix- II: INSAT-3D GeometricCalibration/INSAT-3D SOUNDER.[INSb]INSAT DP Team. INSAT-3D Data Products Format Document. https://www.mosdac.gov.in/docs/INSAT3D</em>Products.pdf.[SPB18]Mrutyunjay Mohapatra Shailesh Parihar, Ashim Kumar Mitra and Rajjev Bhatla. Poten-tial of INSAT-3D sounder-derived total precipitable water product for weather forecast.Atmospheric Measurement Techniques, 11(10):6003–6018, 2018.39</p>
